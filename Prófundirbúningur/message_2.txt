#   List  = [] ordered and changeable. Duplicates OK
#   Set   = {} unordered and immutable, but Add/Remove OK. NO duplicates
#   Tuple = () ordered and unchangeable. Duplicates OK. FASTER
# dictionary =  a collection of {key:value} pairs ordered and changeable. No duplicates


Classes:

1. **Class Definition**:
   - **Syntax**: `class ClassName:`
   - Defines a new class named `ClassName`.

2. **Constructor Method**:
   - **Syntax**: `def __init__(self, arg1, arg2):`
   - Initializes an instance of the class.

3. **Instance Variables**:
   - **Usage**: Defined within methods using `self.variable_name`.
   - Variables that are specific to each instance.

4. **Class Variables**:
   - **Usage**: Defined directly within the class but outside any methods.
   - Variables that are shared by all instances of the class.

5. **Instance Methods**:
   - **Syntax**: `def method_name(self, arg1, arg2):`
   - Functions that operate on an instance of the class.

6. **Class Methods**:
   - **Syntax**: `@classmethod\ndef method_name(cls, arg1, arg2):`
   - Functions that operate on the class itself, rather than class instances.

7. **Static Methods**:
   - **Syntax**: `@staticmethod\ndef method_name(arg1, arg2):`
   - Functions that don't operate on an instance or the class.

8. **Inheritance**:
   - **Syntax**: `class DerivedClass(BaseClass):`
   - Allows a class to inherit methods and properties from another class.

9. **Method Overriding**:
   - Redefining a method in a subclass that was defined in a parent class.

10. **Private Members**:
    - **Usage**: Prefix the member name with double underscores `__`.
    - Indicates that the member is intended to be private and not accessible outside the class.

11. **Special Methods**:
    - **Example**: `__str__`, `__repr__`
    - Predefined methods with special behavior (like converting to string, representation, etc.).

12. **Property Decorators**:
    - **Syntax**: `@property`
    - Used for defining getters, setters, and deleters.
 

Dictionaries


1. **Creating a Dictionary**
   - Empty dictionary: `my_dict = {}`
   - Dictionary with initial values: `my_dict = {'key1': 'value1', 'key2': 'value2'}`

2. **Accessing Elements**
   - Access value by key: `value = my_dict['key1']`
   - Get with default: `value = my_dict.get('key1', 'default_value')`

3. **Adding or Modifying Elements**
   - Add or update: `my_dict['new_key'] = 'new_value'`
   - Update multiple: `my_dict.update({'key1': 'new_value1', 'key3': 'value3'})`

4. **Deleting Elements**
   - Remove specific element: `del my_dict['key1']`
   - Remove and return: `value = my_dict.pop('key1', 'default_value')`
   - Clear all elements: `my_dict.clear()`

5. **Iterating over a Dictionary**
   - Keys: `for key in my_dict.keys():`
   - Values: `for value in my_dict.values():`
   - Key-value pairs: `for key, value in my_dict.items():`

6. **Dictionary Comprehensions**
   - Syntax: `{key: value for (key, value) in iterable}`
   - Example: `{x: x**2 for x in range(5)}`

7. **Useful Methods**
   - Length: `len(my_dict)`
   - Copy: `my_dict.copy()`
   - Nested dictionaries: Accessing nested elements, e.g., `my_dict['outer_key']['inner_key']`

8. **Handling Exceptions**
   - KeyError: Handle missing keys with try-except
   - Example:
     ```python
     try:
         value = my_dict['unknown_key']
     except KeyError:
         value = 'default'
     ```

9. **Sorting**
   - Sort by keys: `sorted_dict = dict(sorted(my_dict.items()))`
   - Sort by values: `sorted_dict = dict(sorted(my_dict.items(), key=lambda item: item[1]))`
 

Lists


1. **Creating a List**
   - Empty list: `my_list = []`
   - List with elements: `my_list = [1, 2, 3, 'a', 'b']`

2. **Accessing Elements**
   - By index (starts at 0): `element = my_list[0]` (first element)
   - Negative indexing: `element = my_list[-1]` (last element)

3. **Adding Elements**
   - Append at end: `my_list.append('new_element')`
   - Insert at specific position: `my_list.insert(1, 'new_element')` (position 1)

4. **Removing Elements**
   - Remove by value: `my_list.remove('a')` (removes first occurrence)
   - Remove by index and get it: `element = my_list.pop(1)` (position 1)
   - Clear all elements: `my_list.clear()`

5. **Slicing Lists**
   - Subset of list: `sub_list = my_list[1:3]` (elements from position 1 to 2)
   - Skip step slicing: `sub_list = my_list[::2]` (every second element)

6. **List Comprehensions**
   - Syntax: `[expression for item in iterable]`
   - Example: `[x**2 for x in range(5)]` (squares of numbers 0-4)

7. **Iterating over a List**
   - Simple iteration: `for element in my_list:`
   - With index: `for index, element in enumerate(my_list):`

8. **Sorting and Reversing**
   - Sort list: `my_list.sort()` (alters the original list)
   - Sorted list: `sorted_list = sorted(my_list)` (creates a new sorted list)
   - Reverse list: `my_list.reverse()` or `reversed_list = my_list[::-1]`

9. **List Length**
   - Length of list: `length = len(my_list)`

10. **Join and Split Strings**
    - Join list into string: `my_string = ','.join(my_list)` (if elements are strings)
    - Split string into list: `my_list = my_string.split(',')`

11. **Copying Lists**
    - Shallow copy: `my_list_copy = my_list[:]` or `my_list_copy = list(my_list)`
    - Deep copy (for lists of lists): `import copy; my_list_deep_copy = copy.deepcopy(my_list)`

12. **List Operations**
    - Concatenation: `combined_list = list_one + list_two`
    - Repetition: `repeated_list = my_list * 2`

13. **Checking for an Element**
    - Check existence: `if 'a' in my_list:`

14. **Conversion to Other Types**
    - To tuple: `my_tuple = tuple(my_list)`

 
Tuples


1. **Creating a Tuple**
   - Empty tuple: `my_tuple = ()`
   - Tuple with elements: `my_tuple = (1, 2, 3, 'a', 'b')`
   - Single element tuple: `singleton = (1,)` (note the comma)

2. **Accessing Elements**
   - By index (starts at 0): `element = my_tuple[0]` (first element)
   - Negative indexing: `element = my_tuple[-1]` (last element)

3. **Slicing Tuples**
   - Subset of tuple: `sub_tuple = my_tuple[1:3]` (elements from position 1 to 2)
   - Skip step slicing: `sub_tuple = my_tuple[::2]` (every second element)

4. **Tuple Length**
   - Length of tuple: `length = len(my_tuple)`

5. **Iterating over a Tuple**
   - Simple iteration: `for element in my_tuple:`
   - With index: `for index, element in enumerate(my_tuple):`

6. **Concatenation and Repetition**
   - Concatenate tuples: `combined_tuple = tuple_one + tuple_two`
   - Repeat tuple: `repeated_tuple = my_tuple * 2`

7. **Checking for an Element**
   - Check existence: `if 'a' in my_tuple:`

8. **Count and Index**
   - Count occurrences: `count = my_tuple.count('a')`
   - Find first index: `index = my_tuple.index('a')` (throws ValueError if not found)

9. **Immutability**
   - Tuples are immutable: Cannot change, add, or remove elements after creation.
   - Workaround for modification: Convert to list, modify, and convert back to tuple.

10. **Nested Tuples**
    - Accessing nested elements: `element = my_tuple[0][1]` (for tuple of tuples)

11. **Conversion to Other Types**
    - To list: `my_list = list(my_tuple)`
    - From list: `my_tuple = tuple(my_list)`

12. **Tuple Unpacking**
    - Assign each value to a variable: `a, b, c = my_tuple`

13. **Tuple as Dictionary Key**
    - Use as key in a dictionary: `my_dict = {(1, 2): 'value1', (3, 4): 'value2'}`

14. **Comparing Tuples**
    - Tuples can be compared using `==`, `!=`, `<`, `>`, etc., based on lexicographical order.



Sets


1. **Creating a Set**
   - Empty set: `my_set = set()`
   - Set with elements: `my_set = {1, 2, 3, 'a', 'b'}`
   - Note: `{}` creates an empty dictionary, not a set.

2. **Adding Elements**
   - Add single element: `my_set.add('new_element')`
   - Add multiple elements: `my_set.update(['element1', 'element2'])`

3. **Removing Elements**
   - Remove specific element (throws KeyError if not found): `my_set.remove('a')`
   - Discard element (no error if not found): `my_set.discard('a')`
   - Pop random element: `element = my_set.pop()`
   - Clear all elements: `my_set.clear()`

4. **Set Operations**
   - Union: `union_set = set1 | set2` or `set1.union(set2)`
   - Intersection: `intersection_set = set1 & set2` or `set1.intersection(set2)`
   - Difference: `difference_set = set1 - set2` or `set1.difference(set2)`
   - Symmetric difference (elements in either set, but not both): `sym_diff_set = set1 ^ set2` or `set1.symmetric_difference(set2)`

5. **Checking Membership**
   - Check if element is in set: `if 'a' in my_set:`

6. **Set Length**
   - Number of elements in set: `length = len(my_set)`

7. **Iterating over a Set**
   - Iterate through elements: `for element in my_set:`

8. **Set Comprehensions**
   - Syntax: `{expression for item in iterable}`
   - Example: `{x**2 for x in range(5)}` (set of squares)

9. **Subset, Superset, and Disjoint**
   - Check subset: `set1.issubset(set2)`
   - Check superset: `set1.issuperset(set2)`
   - Check disjoint: `set1.isdisjoint(set2)`

10. **Frozen Sets**
    - Immutable sets: `frozen_set = frozenset([1, 2, 3])`
    - Can be used as keys in dictionaries.

11. **Conversion to Other Types**
    - To list: `my_list = list(my_set)`
    - From list: `my_set = set(my_list)`

12. **Comparing Sets**
    - Sets can be compared with `==`, `!=` for equality and inequality.


Lambda


1. **Lambda Function Basics**
   - Syntax: `lambda arguments: expression`
   - It's an anonymous function, i.e., a function without a name.
   - Can take any number of arguments, but can only have one expression.

2. **Simple Usage**
   - Single argument: `f = lambda x: x + 10` (function to add 10)
   - Multiple arguments: `f = lambda x, y: x * y` (function to multiply two numbers)

3. **Use in Built-in Functions**
   - `map`: `result = map(lambda x: x + 10, my_list)` (add 10 to each item in `my_list`)
   - `filter`: `result = filter(lambda x: x % 2 == 0, my_list)` (filter even numbers from `my_list`)
   - `sorted`: `sorted_list = sorted(my_list, key=lambda x: x[1])` (sort `my_list` based on second element of each tuple)

4. **With Conditional Logic**
   - Conditional expression: `f = lambda x: 'Even' if x % 2 == 0 else 'Odd'` (return 'Even' or 'Odd')

5. **As an Inline Function**
   - Usage in small one-off functions: `(lambda x: x + 1)(10)` (returns 11)

6. **Lambda and List Comprehensions**
   - Combining with list comprehensions: `[lambda x: x * i for i in range(5)]` (list of lambda functions)

7. **Scope and Variables**
   - Lambdas can access variables from their containing scope, but can't modify them.

8. **Passing Lambda as Argument**
   - Passing a lambda function to another function: `def apply_func(f, value): return f(value)`

9. **Returning Lambda from Function**
   - Returning lambda from a function: `def make_incrementor(n): return lambda x: x + n`

10. **Lambda with Default Arguments**
    - Default arguments: `f = lambda x, y=2: x + y` (y defaults to 2 if not provided)

11. **Lambda in List Sorting**
    - Custom sort order: `sorted(my_list, key=lambda x: x['key'])` (sort a list of dictionaries by the value of 'key')

12. **Lambda with Map and Reduce**
    - `map`: Apply lambda to each item in a list.
    - `reduce`: Import from `functools` and use to cumulatively apply a lambda to items.

13. **Limitations**
    - Only suitable for simple, short functions.
    - Can reduce readability when overused or for complex operations.

